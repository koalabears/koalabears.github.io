{
  "name": "tap",
  "version": "1.4.1",
  "author": {
    "name": "Isaac Z. Schlueter",
    "email": "i@izs.me",
    "url": "http://blog.izs.me"
  },
  "description": "A Test-Anything-Protocol library",
  "bin": {
    "tap": "bin/run.js"
  },
  "main": "lib/root.js",
  "engines": {
    "node": ">=0.8"
  },
  "dependencies": {
    "coveralls": "^2.11.2",
    "deeper": "^2.1.0",
    "foreground-child": "^1.2.0",
    "glob": "^5.0.6",
    "js-yaml": "^3.3.1",
    "mkdirp": "^0.5.0",
    "nyc": "^3.1.0",
    "only-shallow": "^1.0.2",
    "opener": "^1.4.1",
    "readable-stream": "^2.0.2",
    "signal-exit": "^2.0.0",
    "supports-color": "^1.3.1",
    "tap-mocha-reporter": "0.0 || 1",
    "tap-parser": "^1.2.2"
  },
  "bundleDependencies": [
    "deep-equal"
  ],
  "keywords": [
    "assert",
    "test",
    "tap"
  ],
  "license": "ISC",
  "repository": {
    "type": "git",
    "url": "https://github.com/isaacs/node-tap.git"
  },
  "scripts": {
    "test": "node bin/run.js test/*.* --coverage"
  },
  "devDependencies": {
    "which": "^1.1.1"
  },
  "files": [
    "lib/assert.js",
    "lib/mocha.js",
    "lib/root.js",
    "lib/stack.js",
    "lib/synonyms.js",
    "lib/test.js",
    "bin/mochatap.js",
    "bin/run.js",
    "bin/usage.txt"
  ],
  "config": {
    "nyc": {
      "exclude": [
        "\\bnode_modules\\b",
        "\\btest[\\/]"
      ]
    }
  },
  "readme": "# node-tap\n\nA TAP test framework for Node.js.\n\nThis is a mix-and-match set of utilities that you can use to write test\nharnesses and frameworks that communicate with one another using the\nTest Anything Protocol.\n\nIt is also a test runner for consuming TAP-generating test scripts,\nand a framework for writing such scripts.\n\n[![Coverage Status](https://coveralls.io/repos/isaacs/node-tap/badge.svg?branch=master)](https://coveralls.io/r/isaacs/node-tap?branch=master)\n\n## USAGE\n\nWrite your tests in JavaScript\n\n```javascript\nvar tap = require('tap')\n\n// you can test stuff just using the top level object.\n// no suites or subtests required.\n\ntap.equal(1, 1, 'check if numbers still work')\ntap.notEqual(1, 2, '1 should not equal 2')\n\n// also you can group things into sub-tests.\n// Sub-tests will be run in sequential order always,\n// so they're great for async things.\n\ntap.test('first stuff', function (t) {\n  t.ok(true, 'true is ok')\n  t.similar({a: [1,2,3]}, {a: [1,2,3]})\n  // call t.end() when you're done\n  t.end()\n})\n\n// If you have a bunch of setup stuff that MUST work or else\n// the rest of the tests are not worth running, then you can\n// pass `{ bail: true }` to make it bail out on failure.\n\ntap.test('must succeed or all is lost', { bail: true }, function (t) {\n  db = new DataBorscht()\n  t.ok(db, 'borscht setup must succeed')\n  t.end()\n})\n\n// You can also bail out based on specific conditions, or with a\n// different error message of your choosing.\ntap.test('must mostly succeed or all is lost', function (t) {\n  db = new DataBorscht()\n\n  t.ok(db, 'borscht setup')\n  if (!db) {\n    t.bailout('the borscht is lost.  I cannot continue.')\n    return\n  }\n\n  t.ok(db.connection, 'db must have connection')\n  t.ok(db.username, 'db must have username')\n  t.equal(db.color, 'red', 'borscht should be red')\n  if (!t.passing())\n    t.bailout('something weird with the data borscht.')\n\n  t.end()\n})\n\n// you can specify a 'plan' if you know how many\n// tests there will be in advance. Handy when\n// order is irrelevant and things happen in parallel.\n\ntap.test('planned test', function (t) {\n  t.plan(2)\n  setTimeout(function () {\n    t.ok(true, 'a timeout')\n  })\n  setTimeout(function () {\n    t.ok(true, 'b timeout')\n  })\n})\n\n// you can do `var test = require('tap').test` if you like\n// it's pre-bound to the root tap object.\n\nvar test = require('tap').test\n\n// subtests can have subtests\ntest('parent', function (t) {\n  t.test('child', function (tt) {\n    tt.throws(function () {\n      throw new Error('fooblz')\n    }, {\n      message: 'fooblz'\n    }, 'throw a fooblz')\n\n    tt.throws(function () { throw 1 }, 'throw whatever')\n\n    tt.end()\n  })\n\n  t.end()\n})\n\n// thrown errors just fail the current test, so you can\n// also use your own assert library if you like.\n// Of course, this means it won't be able to print out the\n// number of passing asserts, since passes will be silent.\n\ntest('my favorite assert lib', function (t) {\n  var assert = require('assert')\n  assert.ok(true, 'true is ok')\n  assert.equal(1, 1, 'math works')\n\n  // Since it can't read the plan, using a custom assert lib\n  // means that you MUST use t.end()\n  t.end()\n})\n\n// You can mark tests as 'todo' either using a conf object,\n// or simply by omitting the callback.\ntest('solve halting problem')\ntest('prove p=np', { todo: true }, function (t) {\n  // i guess stuff goes here\n  t.fail('traveling salesmen must pack their own bags')\n  t.end()\n})\n\n// Prefer mocha/rspec/lab style global objects?\n// Got you covered.  This is a little experimental,\n// patches definitely welcome.\ntap.mochaGlobals()\ndescribe('suite ride bro', function () {\n  it('should have a wheel', function () {\n    assert.ok(thingie.wheel, 'wheel')\n  })\n  it('can happen async', function (done) {\n    setTimeout(function () {\n      assert.ok('ok')\n      done()\n    })\n  })\n})\n\n// Read on for a complete list of asserts, methods, etc.\n```\n\nYou can run tests using the `tap` executable.  Put this in your\npackage.json file:\n\n```json\n{\n  \"scripts\": {\n    \"test\": \"tap test/*.js\"\n  }\n}\n```\n\nand then you can run `npm test` to run your test scripts.\n\nCommand line behavior and flags:\n\n```\n$ tap -h\nUsage:\n  tap [options] <files>\n\nExecutes all the files and interprets their output as TAP\nformatted test result data.\n\nTo parse TAP data from stdin, specify \"-\" as a filename.\n\nOptions:\n\n  -c --color                  Force use of colors\n\n  -C --no-color               Force no use of colors\n\n  -b --bail                   Bail out on first failure\n\n  -B --no-bail                Do not bail out on first failure (Default)\n\n  -R<type> --reporter=<type>  Use the specified reporter.  Defaults to\n                              'classic' when colors are in use, or 'tap'\n                              when colors are disabled.\n\n                              Available reporters:\n                              classic doc dot dump html htmlcov json\n                              jsoncov jsonstream landing list markdown\n                              min nyan progress silent spec tap xunit\n\n  -gc --expose-gc             Expose the gc() function to Node tests\n\n  --debug                     Run JavaScript tests with node --debug\n\n  --debug-brk                 Run JavaScript tests with node --debug-brk\n\n  --harmony                   Enable all Harmony flags in JavaScript tests\n\n  --strict                    Run JS tests in 'use strict' mode\n\n  -t<n> --timeout=<n>         Time out tests after this many seconds.\n                              Defaults to 30, or the value of the\n                              TAP_TIMEOUT environment variable.\n\n  -h --help                   print this thing you're looking at\n\n  -v --version                show the version of this program\n\n  --                          Stop parsing flags, and treat any additional\n                              command line arguments as filenames.\n```\n\n## Coverage\n\nThis module uses [nyc](http://npm.im/nyc) to track code coverage, even\nacross subprocess boundaries.  It is included by default, and there's\nnothing you need to do but enable it.  Adding coverage *will* make\nyour tests run slightly slower, but that's to be expected.\n\nTo generate coverage information, run your tests with the `--cov`\nargument.\n\nTo specify a report format, you can use `--coverage-report=<type>`.\nThe default type is `text`, which produces a pretty text-only table on\nthe terminal.  If you specify `--coverage-report=lcov`, then tap will\nattempt to open a web browser to view the report after the test run.\n\nIf you use this a lot, you may want to add `coverage` and\n`.nyc_output` to your `.gitignore` and/or `.npmignore` files.\n\n### Travis-CI and Coveralls.io Integration\n\nYou can very easily take advantage of continuous test coverage reports\nby using [Travis-CI](https://travis-ci.org) and\n[Coveralls](https://coveralls.io).\n\n1. Enable Travis-CI by signing up, enabling tests on your repo, and\n   adding a `.travis.yml` file to your repo.  You can use [this\n   module's .travis.yml file as an\n   example](https://github.com/isaacs/node-tap/blob/master/.travis.yml)\n2. Enable Coveralls.io by signing up, and adding the repo.  Note the\n   repo API token.\n3. Back at Travis-CI, add a private environment variable.  The name of\n   the environment variable is `COVERALLS_REPO_TOKEN` and the value is\n   the token you got from coveralls.\n4. When that token is set in the environment variable, `tap` will\n   automatically generate coverage information and send it to\n   coveralls.\n\n## API\n\n### tap = require('tap')\n\nThe root `tap` object is an instance of the Test class with a few\nslight modifications.\n\n1. The `teardown()`, `plan()`, and `test()` methods are pre-bound onto\n   the root object, so that you don't have to call them as methods.\n2. By default, it pipes to stdout, so running a test directly just\n   dumps the TAP data for inspection.  (You can of course\n   `tap.unpipe(process.stdout)` if you want to direct it elsewhere.)\n3. Various other things are hung onto it for convenience, since it is\n   the main package export.\n4. The test ends automatically when `process.on('exit')` fires, so\n   there is no need to call `tap.end()` explicitly.\n5. Adding a `teardown` function triggers `autoend` behavior.\n   Otherwise, the `end` would potentially never arrive, if for example\n   `teardown` is used to close a server or cancel some long-running\n   process, because `process.on('exit')` would never fire of its own\n   accord.\n\n### tap.synonyms\n\nA list of all of the canonical assert methods and their synonyms.\n\n### tap.mochaGlobals()\n\nMethod that injects `describe()` and `it()` into the global\nenvironment for mocha-like BDD style test definition.\n\nThis feature is incomplete, experimental, and may change drastically\nin the future.  Feedback is welcome.\n\n### tap.Test\n\nThe `Test` class is the main thing you'll be touching when you use\nthis module.\n\nThe most common way to instantiate a `Test` object by calling the\n`test` method on the root or any other `Test` object.  The callback\npassed to `test(name, fn)` will receive a child `Test` object as its\nargument.\n\nA `Test` object is a Readable Stream.  Child tests automatically send\ntheir data to their parent, and the root `require('tap')` object pipes\nto stdout by default.  However, you can instantiate a `Test` object\nand then pipe it wherever you like.  The only limit is your imagination.\n\n#### t.test(name, [options], [function])\n\nCreate a subtest.\n\nIf the function is omitted, then it will be marked as a \"todo\" or\n\"pending\" test.\n\nThe options object is the same as would be passed to any assert, with\ntwo additional fields that are only relevant for child tests:\n\n* `timeout`: The number of ms to allow the test to run.\n* `bail`: Set to `true` to bail out on the first test failure.\n* `autoend`: Automatically `end()` the test on the next turn of the\n  event loop after its internal queue is drained.\n\n#### t.tearDown(function)\n\nRun the supplied function when `t.end()` is called, or when the `plan`\nis met.\n\nNote that when called on the root `tap` export, this also triggers\n`autoend` behavior.\n\n#### t.autoend()\n\nAutomatically end the test as soon as there is nothing pending in its\nqueue.\n\nThe automatic end is deferred with a `setTimeout`, and any new action\nwill cancel and re-schedule the timer.  Nonetheless, calling this\nmethod means that any slow asynchronous behavior may be lost, if it\ncomes after the `end()` is auto-triggered.\n\nThis behavior is triggered on the root `tap` object when\n`tap.tearDown()` is called.\n\n#### t.plan(number)\n\nSpecify that a given number of tests are going to be run.\n\nThis may only be called *before* running any asserts or child tests.\n\n#### t.end()\n\nCall when tests are done running.  This is not necessary if `t.plan()`\nwas used.\n\n#### t.bailout([reason])\n\nPull the proverbial ejector seat.\n\nUse this when things are severely broken, and cannot be reasonably\nhandled.  Immediately terminates the entire test run.\n\n#### t.passing()\n\nReturn true if everything so far is ok.\n\nNote that all assert methods also return `true` if they pass.\n\n#### t.comment(message)\n\nPrint the supplied message as a TAP comment.\n\nNote that you can always use `console.error()` for debugging (or\n`console.log()` as long as the message doesn't look like TAP formatted\ndata).\n\n#### t.fail(message, extra)\n\nEmit a failing test point.  This method, and `pass()`, are the basic\nbuilding blocks of all fancier assertions.\n\n#### t.pass(message)\n\nEmit a passing test point.  This method, and `fail()`, are the basic\nbuilding blocks of all fancier assertions.\n\n#### t.pragma(set)\n\nSets a `pragma` switch for a set of boolean keys in the argument.\n\nThe only pragma currently supported by the TAP parser is `strict`,\nwhich tells the parser to treat non-TAP output as a failure.\n\nExample:\n\n```\nvar t = require('tap')\nconsole.log('this non-TAP output is ok')\nt.pragma({ strict: true })\nconsole.log('but this will cause a failure')\n```\n\n### Advanced Usage\n\nThese methods are primarily for internal use, but can be handy in some\nunusual situations.  If you find yourself using them frequently, you\n*may* be Doing It Wrong.  However, if you find them useful, you should\nfeel perfectly comfortable using them.\n\n#### t.stdin()\n\nParse standard input as if it was a child test named `/dev/stdin`.\n\nThis is primarily for use in the test runner, so that you can do\n`some-tap-emitting-program | tap other-file.js - -Rnyan`.\n\n#### t.spawn(command, arguments, [options], [name], [extra])\n\nSometimes, instead of running a child test directly inline, you might\nwant to run a TAP producting test as a child process, and treat its\nstandard output as the TAP stream.\n\nThat's what this method does.\n\nIt is primarily used by the executable runner, to run all of the\nfilename arguments provided on the command line.\n\nThe `options` object is passed to `child_process.spawn`, and can\ncontain stuff like stdio directives and environment vars.\n\nThe `extra` arg is the same that would be passed to any assertion or\nchild test, with the addition of the following fields:\n\n* `bail`: Set to `true` to bail out on the first failure.  This is\n  done by checking the output and then forcibly killing the process,\n  but also sets the `TAP_BAIL` environment variable, which node-tap\n  uses to set this field internally as well.\n* `timeout`: The number of ms to allow the child process to continue.\n  If it goes beyond this time, the child process will be forcibly\n  killed.\n\n#### t.addAssert(name, length, fn)\n\nThis is used for creating assertion methods on the `Test` class.\n\nIt's a little bit advanced, but it's also super handy sometimes.  All\nof the assert methods below are created using this function, and it\ncan be used to create application-specific assertions in your tests.\n\nThe name is the method name that will be created.  The length is the\nnumber of arguments the assertion operates on.  (The `message` and\n`extra` arguments will alwasy be appended to the end.)\n\nFor example, you could have a file at `test/setup.js` that does the\nfollowing:\n\n```javascript\nvar tap = require('tap')\n\n// convenience\nif (module === require.main) {\n  tap.pass('ok')\n  return\n}\n\n// Add an assertion that a string is in Title Case\n// It takes one argument (the string to be tested)\ntap.Test.prototype.addAssert('titleCase', 1, function (str, message, extra) {\n  message = message || 'should be in Title Case'\n  // the string in Title Case\n  // A fancier implementation would avoid capitalizing little words\n  // to get `Silence of the Lambs` instead of `Silence Of The Lambs`\n  // But whatever, it's just an example.\n  var tc = str.toLowerCase().replace(/\\b./, function (match) {\n    return match.toUpperCase()\n  })\n\n  // should always return another assert call, or\n  // this.pass(message) or this.fail(message, extra)\n  return this.equal(str, tc, message, extra)\n})\n```\n\nThen in your individual tests, you'd do this:\n\n```javascript\nrequire('./setup.js') // adds the assert\nvar tap = require('tap')\ntap.titleCase('This Passes')\ntap.titleCase('however, tHis tOTaLLy faILS')\n```\n\n#### t.endAll()\n\nCall the `end()` method on all child tests, and then on this one.\n\n#### t.current()\n\nReturn the currently active test.\n\n### Asserts\n\nThe `Test` object has a collection of assertion methods, many of which\nare given several synonyms for compatibility with other test runners\nand the vagaries of human expectations and spelling.  When a synonym\nis multi-word in `camelCase` the corresponding lower case and\n`snake_case` versions are also created as synonyms.\n\nAll assertion methods take optional `message` and `extra` arguments as\nthe last two params.  The `message` is the name of the test.  The\n`extra` argument can contain any arbitrary data about the test, but\nthe following fields are \"special\".\n\n* `todo` Set to boolean `true` or a String to mark this as pending\n* `skip` Set to boolean `true` or a String to mark this as skipped\n* `at` Generated by the framework.  The location where the assertion\n  was called.  Do not set.\n* `stack` Generated by the framework.  The stack trace to the point\n  where the assertion was called.\n\n#### ok(obj, message, extra)\n\nVerifies that the object is truthy.\n\nSynonyms: `t.true`, `t.assert`\n\n#### notOk(obj, message, extra)\n\nVerifies that the object is not truthy.\n\nSynonyms: `t.false`, `t.assertNot`\n\n#### error(obj, message, extra)\n\nIf the object is an error, then the assertion fails.\n\nNote: if an error is encountered unexpectedly, it's often better to\nsimply throw it.  The Test object will handle this as a failure.\n\nSynonyms: `t.ifErr`, `t.ifError`\n\n#### throws(fn, [expectedError], message, extra)\n\nExpect the function to throw an error.  If an expected error is\nprovided, then also verify that the thrown error matches the expected\nerror.\n\nCaveat: if you pass a `extra` object to t.throws, then you MUST also\npass in an expected error, or else it will read the diag object as the\nexpected error, and get upset when your thrown error doesn't match\n`{skip:true}` or whatever.\n\nFor example, this will not work as expected:\n\n```javascript\nt.throws(function() {throw new Error('x')}, { skip: true })\n```\n\nBut this is fine:\n\n```javascript\n// note the empty 'expected error' object.\n// since it has no fields, it'll only verify that the thrown thing is\n// an object, not the value of any properties\nt.throws(function() {throw new Error('x')}, {}, { skip: true })\n```\n\n\nSynonyms: `t.throw`\n\n#### doesNotThrow(fn, message, extra)\n\nVerify that the provided function does not throw.\n\nNote: if an error is encountered unexpectedly, it's often better to\nsimply throw it.  The Test object will handle this as a failure.\n\nSynonyms: `t.notThrow`\n\n#### equal(found, wanted, message, extra)\n\nVerify that the object found is exactly the same (that is, `===`) to\nthe object that is wanted.\n\nSynonyms: `t.equals`, `t.isEqual`, `t.is`, `t.strictEqual`,\n`t.strictEquals`, `t.strictIs`, `t.isStrict`, `t.isStrictly`\n\n#### notEqual(found, notWanted, message, extra)\n\nInverse of `equal()`.\n\nVerify that the object found is not exactly the same (that is, `!==`) as\nthe object that is wanted.\n\nSynonyms: `t.inequal`, `t.notEqual`, `t.notEquals`,\n`t.notStrictEqual`, `t.notStrictEquals`, `t.isNotEqual`, `t.isNot`,\n`t.doesNotEqual`, `t.isInequal`\n\n#### same(found, wanted, message, extra)\n\nVerify that the found object is deeply equivalent to the wanted\nobject.  Use non-strict equality for scalars (ie, `==`).\n\nSynonyms: `t.equivalent`, `t.looseEqual`, `t.looseEquals`,\n`t.deepEqual`, `t.deepEquals`, `t.isLoose`, `t.looseIs`\n\n#### notSame(found, notWanted, message, extra)\n\nInverse of `same()`.\n\nVerify that the found object is not deeply equivalent to the\nunwanted object.  Uses non-strict inequality (ie, `!=`) for scalars.\n\nSynonyms: `t.inequivalent`, `t.looseInequal`, `t.notDeep`,\n`t.deepInequal`, `t.notLoose`, `t.looseNot`\n\n#### strictSame(found, wanted, message, extra)\n\nStrict version of `same()`.\n\nVerify that the found object is deeply equivalent to the wanted\nobject.  Use strict equality for scalars (ie, `===`).\n\nSynonyms: `t.strictEquivalent`, `t.strictDeepEqual`, `t.sameStrict`,\n`t.deepIs`, `t.isDeeply`, `t.isDeep`, `t.strictDeepEquals`\n\n#### strictNotSame(found, notWanted, message, extra)\n\nInverse of `strictSame()`.\n\nVerify that the found object is not deeply equivalent to the unwanted\nobject.  Use strict equality for scalars (ie, `===`).\n\nSynonyms: `t.strictInequivalent`, `t.strictDeepInequal`,\n`t.notSameStrict`, `t.deepNot`, `t.notDeeply`, `t.strictDeepInequals`,\n`t.notStrictSame`\n\n#### match(found, pattern, message, extra)\n\nVerify that the found object matches the pattern provided.\n\nIf pattern is a regular expression, and found is a string, then verify\nthat the string matches the pattern.\n\nIf the pattern is a string, and found is a string, then verify that\nthe pattern occurs within the string somewhere.\n\nIf pattern is an object, the verify that the found object contains all\nthe keys in the pattern, and that all of the found object's values\nmatch the corresponding fields in the pattern.\n\nThis is useful when you want to verify that an object has a certain\nset of required fields, but additional fields are ok.\n\n\nSynonyms: `t.has`, `t.hasFields`, `t.matches`, `t.similar`, `t.like`,\n`t.isLike`, `t.includes`, `t.include`, `t.contains`\n\n#### notMatch(found, pattern, message, extra)\n\nInterse of `match()`\n\nVerify that the found object does not match the pattern provided.\n\nSynonyms: `t.dissimilar`, `t.unsimilar`, `t.notSimilar`, `t.unlike`,\n`t.isUnlike`, `t.notLike`, `t.isNotLike`, `t.doesNotHave`,\n`t.isNotSimilar`, `t.isDissimilar`\n\n#### type(object, type, message, extra)\n\nVerify that the object is of the type provided.\n\nType can be a string that matches the `typeof` value of the object, or\nthe string name of any constructor in the object's prototype chain, or\na constructor function in the object's prototype chain.\n\nFor example, all the following will pass:\n\n```javascript\nt.type(new Date(), 'object')\nt.type(new Date(), 'Date')\nt.type(new Date(), Date)\n```\n\nSynonyms: `t.isa`, `t.isA`\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/isaacs/node-tap/issues"
  },
  "_id": "tap@1.4.1",
  "dist": {
    "shasum": "09391fff4c3cb002673101f53fff78b8c183becd"
  },
  "_from": "tap@>=0.2.3",
  "_resolved": "https://registry.npmjs.org/tap/-/tap-1.4.1.tgz"
}
