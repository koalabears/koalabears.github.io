{
  "name": "deeper",
  "version": "2.1.0",
  "description": "JavaScript \"deep equality\" / structural equality tester with Node.js flavor.",
  "scripts": {
    "test": "standard && tap test/*.js --coverage"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/othiym23/node-deeper.git"
  },
  "keywords": [
    "deepEqual",
    "structural",
    "equality",
    "assert",
    "testing",
    "tap"
  ],
  "author": {
    "name": "Forrest L Norvell",
    "email": "ogd@aoaioxxysz.net",
    "url": "https://github.com/othiym23"
  },
  "license": "BSD-2-Clause",
  "devDependencies": {
    "buffertools": "^2.1.3",
    "standard": "^5.1.1",
    "tap": "^1.3.2"
  },
  "readme": "[![deeper on npm](https://img.shields.io/npm/v/deeper.svg?style=flat)](http://npm.im/deeper)\n[![Build Status](https://travis-ci.org/othiym23/node-deeper.svg?branch=master)](https://travis-ci.org/othiym23/node-deeper)\n[![Coverage Status](https://coveralls.io/repos/othiym23/node-deeper/badge.svg?branch=master&service=github)](https://coveralls.io/github/othiym23/node-deeper?branch=master)\n[![\"standard\" style](https://img.shields.io/badge/code%20style-standard-brightgreen.svg?style=flat)](https://github.com/feross/standard)\n\n\n# deeper\n\n`deeper` is a library for structurally comparing the equality of JavaScript\nvalues. It supports recursive / cyclical data structures, is written to avoid\ntry / catch / throw (for speed), and has no dependencies by default.\n\nIf you're running Node 0.12+ or io.js, `deeper` will use the built-in\n`Buffer.equals()`.  If you're running an older version of Node and you install\n[Ben Noordhuis](http://github.com/bnoordhuis)'s\n[buffertools](https://github.com/bnoordhuis/node-buffertools) into a project\nusing `deeper`, it will use that to speed up comparison of Buffers. This used\nto be installed as an optional dependency, but it gets in the way of\nbrowserification and also makes using `deeper` in your own projects harder, so\nI changed it to just try to use it if it's there.\n\nIt has some optimizations, but stresses correctness over raw speed (unless\nyou're testing objects with lots of Buffers attached to them, in which case it\nplus `buffertools` is likely to be the fastest general-purpose deep-comparison\ntool available).\n\nThe core algorithm is based on those used by Node's assertion library and the\nimplementation of cycle detection in\n[isEqual](http://underscorejs.org/#isEqual) in\n[Underscore.js](http://underscorejs.org/).\n\nI like to think the documentation is pretty OK.\n\n## installation\n\n```\nnpm install deeper\n```\n\n## usage\n\n```javascript\n// vanilla\nvar deepEqual = require('deeper')\n\nif (!deepEqual(obj1, obj2)) console.log(\"yay! diversity!\");\n```\n\n## details\n\nCopied from the source, here are the details of `deeper`'s algorithm:\n\n1. `===` only tests objects and functions by reference. `null` is an object.\n   Any pairs of identical entities failing this test are therefore objects\n   (including `null`), which need to be recursed into and compared attribute by\n   attribute.\n2. Since the only entities to get to this test must be objects, if `a` or `b`\n   is not an object, they're clearly not the same. All unfiltered `a` and `b`\n   getting past this are objects (including `null`).\n3. `null` is an object, but `null === null.` All unfiltered `a` and `b` are\n   non-null `Objects`.\n4. Buffers need to be special-cased because they live partially on the wrong\n   side of the C++ / JavaScript barrier. Still, calling this on structures\n   that can contain Buffers is a bad idea, because they can contain\n   multiple megabytes of data and comparing them byte-by-byte is hella\n   expensive.\n5. It's much faster to compare dates by numeric value (`.getTime()`) than by\n   lexical value.\n6. Compare `RegExps` by their components, not the objects themselves.\n7. Treat argumens objects like arrays. The parts of an arguments list most\n   people care about are the arguments themselves, not `callee`, which you\n   shouldn't be looking at anyway.\n8. Objects are more complex:\n    1. Ensure that `a` and `b` are on the same constructor chain.\n    2. Ensure that `a` and `b` have the same number of own properties (which is\n       what `Object.keys()` returns).\n    3. Ensure that cyclical references don't blow up the stack.\n    4. Ensure that all the key names match (faster).\n    5. Ensure that all of the associated values match, recursively (slower).\n\n### (somewhat untested) assumptions:\n\n- Functions are only considered identical if they unify to the same reference.\n  To anything else is to invite the wrath of the halting problem.\n- V8 is smart enough to optimize treating an Array like any other kind of\n  object.\n- Users of this function are cool with mutually recursive data structures that\n  are otherwise identical being treated as the same.\n\n## license\nBSD. Go nuts.\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/othiym23/node-deeper/issues"
  },
  "_id": "deeper@2.1.0",
  "dist": {
    "shasum": "00585e1f6903781633642d0572bb612a1b52e05e"
  },
  "_from": "deeper@^2.1.0",
  "_resolved": "https://registry.npmjs.org/deeper/-/deeper-2.1.0.tgz"
}
